import enum
import datetime
import decimal
import hashlib
import uuid
from collections.abc import Collection, Mapping
from typing import Generic, TypeVar, cast

import aiohttp
import msgspec

from pagopar import _app, _errors

T = TypeVar("T")

__all__ = ()


JSONStrOrNum = (
    decimal.Decimal
    | uuid.UUID
    | datetime.datetime
    | datetime.date
    | datetime.time
    | datetime.timedelta
    | enum.Enum
    | float
    | str
    | bytes
)

JSON = (
    Collection["JSON"]
    | Mapping[JSONStrOrNum, "JSON"]
    | msgspec.Struct
    | msgspec.Raw
    | msgspec.msgpack.Ext
    | JSONStrOrNum
    | bytearray
    | None
)

JSONQuery = dict[str, list[float | str] | float | str]


class Response(msgspec.Struct, Generic[T]):
    success: bool = msgspec.field(name="respuesta")
    payload: T | str = msgspec.field(default="", name="resultado")


encoder = msgspec.json.Encoder()


def create_session(proxy: str | None) -> aiohttp.ClientSession:
    """
    Create a new aiohttp ClientSession configured for Pagopar API.

    Parameters
    ----------
    proxy : str, optional
        Proxy URL for network requests.

    Returns
    -------
    aiohttp.ClientSession
        Configured client session.
    """
    return aiohttp.ClientSession(
        "https://api.pagopar.com/api/",
        headers={aiohttp.hdrs.ACCEPT: "application/json"},
        proxy=proxy,
    )


def create_token(token_data: str, app: "_app.Application | None" = None) -> str:
    """
    Generate the SHA1 authentication token for a request.

    The token is generated by concatenating the commerce private token
    and the specific data for the endpoint, then computing the SHA1 hash.

    Parameters
    ----------
    token_data : str
        Data string specific to the endpoint request (e.g., amount, order ID).
    app : Application, optional
        Pagopar application configuration.

    Returns
    -------
    str
        Hexadecimal SHA1 hash token.
    """
    app = _app.check_initialized_app(app)
    return hashlib.sha1((app.private_token + token_data).encode('utf-8')).hexdigest()


async def send_request(
    method: str,
    path: str,
    token_data: str,
    response_type: type[T],
    payload: dict[str, JSON],
    key_hashed_token: str = "token",
    key_public_token: str = "public_key",
    app: "_app.Application | None" = None,
) -> T:
    """
    Send an authenticated JSON request to the Pagopar API.

    This function handles token generation, payload encoding, request transmission,
    and response decoding.

    Parameters
    ----------
    method : str
        HTTP method (GET, POST, etc.).
    path : str
        API endpoint path relative to the base URL.
    token_data : str
        Data string used to generate the authentication token.
    response_type : type[T]
        Expected return type for decoding the response.
    payload : dict
        Data to include in the request body (POST) or query parameters (GET).
    key_hashed_token : str, optional
        Key name for the hashed token in the payload. Defaults to "token".
    key_public_token : str, optional
        Key name for the public token in the payload. Defaults to "public_key".
    app : Application, optional
        Pagopar application configuration.

    Returns
    -------
    T
        Decoded response payload.

    Raises
    ------
    PagoparError
        If the API returns an error status.
    aiohttp.ClientResponseError
        If the HTTP request itself fails.
    msgspec.DecodeError
        If the response cannot be decoded.
    """
    headers = params = data = None

    app = _app.check_initialized_app(app)

    payload[key_hashed_token] = create_token(token_data, app)
    payload[key_public_token] = app.public_token

    if method in aiohttp.ClientRequest.GET_METHODS:
        params = cast(JSONQuery, payload)
    elif method in aiohttp.ClientRequest.POST_METHODS:
        data = encoder.encode(payload)
        headers = {"Content-Type": "application/json; charset=utf-8"}
    else:
        raise ValueError(f"{method=}")

    async with app.session.request(
        method,
        path,
        params=params,
        data=data,
        headers=headers,
    ) as response:
        decoder = msgspec.json.Decoder(Response[response_type], strict=False)
        try:
            model: Response[T] = await response.json(loads=decoder.decode)
        except msgspec.DecodeError:
            response.raise_for_status()
            raise
    if not model.success:
        raise _errors.parse_error(cast(str, model.payload))
    return cast(T, model.payload)
